// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "./caml.js";
import * as Curry from "./curry.js";
import * as Belt_Id from "./belt_Id.js";
import * as Belt_Map from "./belt_Map.js";
import * as Caml_obj from "./caml_obj.js";
import * as Pervasives from "./pervasives.js";
import * as Caml_option from "./caml_option.js";
import * as Belt_MapDict from "./belt_MapDict.js";
import * as Belt_SetDict from "./belt_SetDict.js";

function reduce(_init, f, _x) {
  while (true) {
    var x = _x;
    var init = _init;
    if (!x) {
      return init;
    }
    var match = x._1;
    _x = match._1;
    _init = f(f(init, x._0), match._0);
    continue;
  }
}

function reverse(l) {
  var _acc = /* Empty */ 0;
  var _x = l;
  while (true) {
    var x = _x;
    var acc = _acc;
    if (!x) {
      return acc;
    }
    var match = x._1;
    _x = match._1;
    _acc = /* Even */ {
      _0: match._0,
      _1: /* Odd */ {
        _0: x._0,
        _1: acc,
      },
    };
    continue;
  }
}

function concat(l1, l2) {
  var _acc = /* Empty */ 0;
  var _l1 = l1;
  var _l2 = l2;
  while (true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var acc = _acc;
    var l1$2;
    var a;
    var b;
    var l2$2;
    if (l1$1) {
      var match = l1$1._1;
      l1$2 = match._1;
      a = l1$1._0;
      b = match._0;
      l2$2 = l2$1;
    } else {
      if (!l2$1) {
        return reverse(acc);
      }
      var match$1 = l2$1._1;
      l1$2 = l1$1;
      a = l2$1._0;
      b = match$1._0;
      l2$2 = match$1._1;
    }
    _l2 = l2$2;
    _l1 = l1$2;
    _acc = /* Even */ {
      _0: b,
      _1: /* Odd */ {
        _0: a,
        _1: acc,
      },
    };
    continue;
  }
}

function reduce$1(_init, f, _x) {
  while (true) {
    var x = _x;
    var init = _init;
    var match = x._1;
    var a = x._0;
    if (!match) {
      return f(init, a);
    }
    _x = match._1;
    _init = f(f(init, a), match._0);
    continue;
  }
}

function reverse$1(param) {
  var _acc = /* Odd */ {
    _0: param._0,
    _1: /* Empty */ 0,
  };
  var _x = param._1;
  while (true) {
    var x = _x;
    var acc = _acc;
    if (!x) {
      return acc;
    }
    var match = x._1;
    _x = match._1;
    _acc = /* Odd */ {
      _0: match._0,
      _1: /* Even */ {
        _0: x._0,
        _1: acc,
      },
    };
    continue;
  }
}

function forEach(f, _x) {
  while (true) {
    var x = _x;
    var match = x._1;
    var a = x._0;
    if (!match) {
      return f(a);
    }
    f(a);
    f(match._0);
    _x = match._1;
    continue;
  }
}

function concat$1(l1, l2) {
  var _acc = reverse$1(l1);
  var _x = l2;
  while (true) {
    var x = _x;
    var acc = _acc;
    var match = x._1;
    var a = x._0;
    if (!match) {
      return reverse(
        /* Even */ {
          _0: a,
          _1: acc,
        }
      );
    }
    _x = match._1;
    _acc = /* Odd */ {
      _0: match._0,
      _1: /* Even */ {
        _0: a,
        _1: acc,
      },
    };
    continue;
  }
}

function concatEven(param, l2) {
  return /* Odd */ {
    _0: param._0,
    _1: concat(param._1, l2),
  };
}

function trimTo(param, f) {
  var _acc = /* Odd */ {
    _0: param._0,
    _1: /* Empty */ 0,
  };
  var _x = param._1;
  while (true) {
    var x = _x;
    var acc = _acc;
    if (!x) {
      return;
    }
    var match = x._1;
    var a = x._0;
    if (f(a)) {
      return reverse$1(acc);
    }
    _x = match._1;
    _acc = /* Odd */ {
      _0: match._0,
      _1: /* Even */ {
        _0: a,
        _1: acc,
      },
    };
    continue;
  }
}

function slack(param) {
  return param.i.dualVar + param.j.dualVar - param.weight;
}

function toVertex(x) {
  if (x.TAG === /* I */ 0) {
    return x._0.i;
  } else {
    return x._0.j;
  }
}

function reverse$2(x) {
  if (x.TAG === /* I */ 0) {
    return {
      TAG: /* J */ 1,
      _0: x._0,
    };
  } else {
    return {
      TAG: /* I */ 0,
      _0: x._0,
    };
  }
}

function toReverseVertex(x) {
  if (x.TAG === /* I */ 0) {
    return x._0.j;
  } else {
    return x._0.i;
  }
}

function eq(a, b) {
  return a.content === b.content;
}

function baseVertex(_x) {
  while (true) {
    var x = _x;
    if (x.TAG === /* Vertex */ 0) {
      return x._0;
    }
    var match = x._0.fields.children;
    _x = match._0.node;
    continue;
  }
}

function eq$1(a, b) {
  if (a.TAG === /* Vertex */ 0) {
    if (b.TAG === /* Vertex */ 0) {
      var a$1 = a._0;
      var b$1 = b._0;
      return a$1.content === b$1.content;
    } else {
      return false;
    }
  } else if (b.TAG === /* Vertex */ 0) {
    return false;
  } else {
    return eq(a._0, b._0);
  }
}

function eqB(a, b) {
  if (a.TAG === /* Vertex */ 0) {
    return false;
  } else {
    return eq(a._0, b);
  }
}

function label(param) {
  return param._0.label;
}

function reduce$2(init, f, x) {
  if (x.TAG === /* Vertex */ 0) {
    return f(init, x._0);
  }
  var children = x._0.fields.children;
  return reduce$1(
    init,
    function (init, param) {
      return reduce$2(init, f, param.node);
    },
    children
  );
}

function arg(leaves, v) {
  return {
    hd: v,
    tl: leaves,
  };
}

function getExn(mates, v, cmp) {
  return Belt_MapDict.getExn(mates, v.content, cmp);
}

function setEdge(mates, edge, cmp) {
  return Belt_MapDict.set(
    Belt_MapDict.set(
      mates,
      edge.i.content,
      {
        TAG: /* J */ 1,
        _0: edge,
      },
      cmp
    ),
    edge.j.content,
    {
      TAG: /* I */ 0,
      _0: edge,
    },
    cmp
  );
}

function set(mates, v, p, cmp) {
  return Belt_MapDict.set(mates, v.content, p, cmp);
}

function has(mates, v, cmp) {
  return Belt_MapDict.has(mates, v.content, cmp);
}

function assignS(v, label, queue) {
  var b = v.fields.inBlossom;
  if (b.TAG === /* Vertex */ 0) {
    v.bestEdge = undefined;
    v.label = label;
  } else {
    var b$1 = b._0;
    b$1.label = label;
    b$1.bestEdge = undefined;
    v.bestEdge = undefined;
    v.label = label;
  }
  return reduce$2(queue, arg, b);
}

function assignT(v, p, mates, queue, cmp) {
  var b = v.fields.inBlossom;
  var label = {
    TAG: /* T */ 1,
    _0: p,
  };
  if (b.TAG === /* Vertex */ 0) {
    v.bestEdge = undefined;
    v.label = label;
  } else {
    var b$1 = b._0;
    b$1.label = label;
    b$1.bestEdge = undefined;
    v.bestEdge = undefined;
    v.label = label;
  }
  var matep = getExn(mates, baseVertex(b), cmp);
  var mate = toVertex(matep);
  return assignS(
    mate,
    {
      TAG: /* S */ 0,
      _0: reverse$2(matep),
    },
    queue
  );
}

function assignTSingle(w, p) {
  w._0.label = {
    TAG: /* T */ 1,
    _0: p,
  };
}

function makeRawEdge(i, j, cmp) {
  var x = cmp(i, j);
  if (x !== 0) {
    if (x > 0) {
      return /* Edge */ {
        _0: i,
        _1: j,
      };
    } else {
      return /* Edge */ {
        _0: j,
        _1: i,
      };
    }
  }
}

function makeCmp(vertexCmp) {
  return function (param, param$1) {
    var match = vertexCmp(param._0, param$1._0);
    var match$1 = vertexCmp(param._1, param$1._1);
    if (match === 0 && match$1 === 0) {
      return 0;
    }
    var e = (match + match$1) | 0;
    if (e !== 0) {
      return e;
    } else {
      return match;
    }
  };
}

var Internal = {};

function makeGraph(rawEdges, id) {
  var cmp = id.BeltCmp.cmp;
  var _rawEdges = rawEdges;
  var _edges = /* [] */ 0;
  var _edgeSet;
  var _vertices = /* [] */ 0;
  var _vertexMap;
  var _vertexSize = 0;
  var _maxWeight = 0;
  while (true) {
    var maxWeight = _maxWeight;
    var vertexSize = _vertexSize;
    var vertexMap = _vertexMap;
    var vertices = _vertices;
    var edgeSet = _edgeSet;
    var edges = _edges;
    var rawEdges$1 = _rawEdges;
    if (rawEdges$1) {
      var rawEdges$2 = rawEdges$1.tl;
      var match = rawEdges$1.hd;
      var weight = match[2];
      var rawEdge = makeRawEdge(match[0], match[1], id.cmp);
      if (rawEdge !== undefined) {
        if (Belt_SetDict.has(edgeSet, rawEdge, id.edgeCmp)) {
          _rawEdges = rawEdges$2;
          continue;
        }
        var jContent = rawEdge._1;
        var iContent = rawEdge._0;
        var maxWeight$1 = maxWeight > weight ? maxWeight : weight;
        var edgeSet$1 = Belt_SetDict.add(edgeSet, rawEdge, id.edgeCmp);
        var match$1 = Belt_MapDict.get(vertexMap, iContent, cmp);
        var match$2 = Belt_MapDict.get(vertexMap, jContent, cmp);
        if (match$1 !== undefined) {
          if (match$2 !== undefined) {
            var edge = {
              i: match$1,
              j: match$2,
              weight: weight,
              allowable: /* NotAllowed */ 1,
            };
            match$1.fields.neighbors = {
              hd: {
                TAG: /* J */ 1,
                _0: edge,
              },
              tl: match$1.fields.neighbors,
            };
            match$2.fields.neighbors = {
              hd: {
                TAG: /* I */ 0,
                _0: edge,
              },
              tl: match$2.fields.neighbors,
            };
            _maxWeight = maxWeight$1;
            _edgeSet = edgeSet$1;
            _edges = {
              hd: edge,
              tl: edges,
            };
            _rawEdges = rawEdges$2;
            continue;
          }
          var edge$1 = {};
          var j = {};
          Caml_obj.update_dummy(edge$1, {
            i: match$1,
            j: j,
            weight: weight,
            allowable: /* NotAllowed */ 1,
          });
          Caml_obj.update_dummy(j, {
            content: jContent,
            parent: undefined,
            dualVar: 0,
            bestEdge: undefined,
            label: /* Free */ 0,
            fields: {
              neighbors: {
                hd: {
                  TAG: /* I */ 0,
                  _0: edge$1,
                },
                tl: /* [] */ 0,
              },
              inBlossom: {
                TAG: /* Vertex */ 0,
                _0: j,
              },
            },
          });
          match$1.fields.neighbors = {
            hd: {
              TAG: /* J */ 1,
              _0: edge$1,
            },
            tl: match$1.fields.neighbors,
          };
          _maxWeight = maxWeight$1;
          _vertexSize = (vertexSize + 1) | 0;
          _vertexMap = Belt_MapDict.set(vertexMap, jContent, j, cmp);
          _vertices = {
            hd: j,
            tl: vertices,
          };
          _edgeSet = edgeSet$1;
          _edges = {
            hd: edge$1,
            tl: edges,
          };
          _rawEdges = rawEdges$2;
          continue;
        }
        if (match$2 !== undefined) {
          var edge$2 = {};
          var i = {};
          Caml_obj.update_dummy(edge$2, {
            i: i,
            j: match$2,
            weight: weight,
            allowable: /* NotAllowed */ 1,
          });
          Caml_obj.update_dummy(i, {
            content: iContent,
            parent: undefined,
            dualVar: 0,
            bestEdge: undefined,
            label: /* Free */ 0,
            fields: {
              neighbors: {
                hd: {
                  TAG: /* J */ 1,
                  _0: edge$2,
                },
                tl: /* [] */ 0,
              },
              inBlossom: {
                TAG: /* Vertex */ 0,
                _0: i,
              },
            },
          });
          match$2.fields.neighbors = {
            hd: {
              TAG: /* I */ 0,
              _0: edge$2,
            },
            tl: match$2.fields.neighbors,
          };
          _maxWeight = maxWeight$1;
          _vertexSize = (vertexSize + 1) | 0;
          _vertexMap = Belt_MapDict.set(vertexMap, iContent, i, cmp);
          _vertices = {
            hd: i,
            tl: vertices,
          };
          _edgeSet = edgeSet$1;
          _edges = {
            hd: edge$2,
            tl: edges,
          };
          _rawEdges = rawEdges$2;
          continue;
        }
        var edge$3 = {};
        var i$1 = {};
        var j$1 = {};
        Caml_obj.update_dummy(edge$3, {
          i: i$1,
          j: j$1,
          weight: weight,
          allowable: /* NotAllowed */ 1,
        });
        Caml_obj.update_dummy(i$1, {
          content: iContent,
          parent: undefined,
          dualVar: 0,
          bestEdge: undefined,
          label: /* Free */ 0,
          fields: {
            neighbors: {
              hd: {
                TAG: /* J */ 1,
                _0: edge$3,
              },
              tl: /* [] */ 0,
            },
            inBlossom: {
              TAG: /* Vertex */ 0,
              _0: i$1,
            },
          },
        });
        Caml_obj.update_dummy(j$1, {
          content: jContent,
          parent: undefined,
          dualVar: 0,
          bestEdge: undefined,
          label: /* Free */ 0,
          fields: {
            neighbors: {
              hd: {
                TAG: /* I */ 0,
                _0: edge$3,
              },
              tl: /* [] */ 0,
            },
            inBlossom: {
              TAG: /* Vertex */ 0,
              _0: j$1,
            },
          },
        });
        _maxWeight = maxWeight$1;
        _vertexSize = (((vertexSize + 1) | 0) + 1) | 0;
        _vertexMap = Belt_MapDict.set(Belt_MapDict.set(vertexMap, iContent, i$1, cmp), jContent, j$1, cmp);
        _vertices = {
          hd: i$1,
          tl: {
            hd: j$1,
            tl: vertices,
          },
        };
        _edgeSet = edgeSet$1;
        _edges = {
          hd: edge$3,
          tl: edges,
        };
        _rawEdges = rawEdges$2;
        continue;
      }
      _rawEdges = rawEdges$2;
      continue;
    }
    var _x = vertices;
    while (true) {
      var x = _x;
      if (!x) {
        return {
          vertices: vertices,
          blossoms: /* [] */ 0,
          nextBlossom: 0,
          maxWeight: maxWeight,
          edges: edges,
          vertexSize: vertexSize,
          cmp: cmp,
        };
      }
      x.hd.dualVar = maxWeight;
      _x = x.tl;
      continue;
    }
  }
}

function updateDualVarsByDelta(graph, delta) {
  var _x = graph.blossoms;
  while (true) {
    var x = _x;
    if (!x) {
      var _x$1 = graph.vertices;
      while (true) {
        var x$1 = _x$1;
        if (!x$1) {
          return;
        }
        var v = x$1.hd;
        var match = label(v.fields.inBlossom);
        var tmp;
        tmp =
          typeof match === "number"
            ? match === /* Free */ 0
              ? v.dualVar
              : v.dualVar - delta
            : match.TAG === /* S */ 0
            ? v.dualVar - delta
            : v.dualVar + delta;
        v.dualVar = tmp;
        _x$1 = x$1.tl;
        continue;
      }
    }
    var b = x.hd;
    var match$1 = b.parent;
    var tmp$1;
    if (match$1 !== undefined) {
      tmp$1 = b.dualVar;
    } else {
      var match$2 = b.label;
      tmp$1 =
        typeof match$2 === "number"
          ? match$2 === /* Free */ 0
            ? b.dualVar
            : b.dualVar + delta
          : match$2.TAG === /* S */ 0
          ? b.dualVar + delta
          : b.dualVar - delta;
    }
    b.dualVar = tmp$1;
    _x = x.tl;
    continue;
  }
}

function traceBackward(w, backChildren) {
  var p = label(w);
  if (typeof p === "number") {
    return {
      TAG: /* DeadEnd */ 0,
      _0: w,
      _1: backChildren,
    };
  }
  if (p.TAG !== /* S */ 0) {
    return Pervasives.failwith("Label should only be S.");
  }
  var p$1 = p._0;
  var w$p = toVertex(p$1).fields.inBlossom;
  var p$p = label(w$p);
  if (typeof p$p === "number") {
    return Pervasives.failwith("Label should only be T.");
  }
  if (p$p.TAG !== /* T */ 1) {
    return Pervasives.failwith("Label should only be T.");
  }
  var p$p$1 = p$p._0;
  var backChildren_0 = {
    node: w$p,
    endpoint: reverse$2(p$p$1),
  };
  var backChildren_1 = /* Odd */ {
    _0: {
      node: w,
      endpoint: reverse$2(p$1),
    },
    _1: backChildren,
  };
  var backChildren$1 = /* Even */ {
    _0: backChildren_0,
    _1: backChildren_1,
  };
  var nextW = toVertex(p$p$1).fields.inBlossom;
  return {
    TAG: /* FoundChild */ 1,
    _0: nextW,
    _1: backChildren$1,
  };
}

function traceForward(v, frontChildren) {
  var p = label(v);
  if (typeof p === "number") {
    return {
      TAG: /* DeadEnd */ 0,
      _0: v,
      _1: frontChildren,
    };
  }
  if (p.TAG !== /* S */ 0) {
    return Pervasives.failwith("Label should only be S.");
  }
  var p$1 = p._0;
  var v$p = toVertex(p$1).fields.inBlossom;
  var p$p = label(v$p);
  if (typeof p$p === "number") {
    return Pervasives.failwith("Label should only be T.");
  }
  if (p$p.TAG !== /* T */ 1) {
    return Pervasives.failwith("Label should only be T.");
  }
  var p$p$1 = p$p._0;
  var lastV = toVertex(p$p$1).fields.inBlossom;
  var frontChildren_0 = {
    node: lastV,
    endpoint: p$p$1,
  };
  var frontChildren_1 = /* Even */ {
    _0: {
      node: v$p,
      endpoint: p$1,
    },
    _1: frontChildren,
  };
  var frontChildren$1 = /* Odd */ {
    _0: frontChildren_0,
    _1: frontChildren_1,
  };
  return {
    TAG: /* FoundChild */ 1,
    _0: lastV,
    _1: frontChildren$1,
  };
}

function findConnection(lastV, nextW, front, back) {
  var children = concatEven(front, reverse(back));
  var children$1 = trimTo(children, function (param) {
    return eq$1(param.node, lastV);
  });
  if (children$1 !== undefined) {
    return children$1;
  } else {
    var f = function (param) {
      return eq$1(param.node, nextW);
    };
    var _x = children;
    while (true) {
      var x = _x;
      var match = x._1;
      if (f(x._0)) {
        return x;
      }
      if (!match) {
        return;
      }
      _x = match._1;
      continue;
    }
  }
}

function scanForBlossom(edge) {
  var initialV = edge.i.fields.inBlossom;
  var _frontPath = {
    TAG: /* FoundChild */ 1,
    _0: initialV,
    _1: /* Odd */ {
      _0: {
        node: initialV,
        endpoint: {
          TAG: /* I */ 0,
          _0: edge,
        },
      },
      _1: /* Empty */ 0,
    },
  };
  var _backPath = {
    TAG: /* FoundChild */ 1,
    _0: edge.j.fields.inBlossom,
    _1: /* Empty */ 0,
  };
  while (true) {
    var backPath = _backPath;
    var frontPath = _frontPath;
    if (frontPath.TAG === /* DeadEnd */ 0) {
      if (backPath.TAG === /* DeadEnd */ 0) {
        return /* AugmentingPath */ 0;
      }
      var back = backPath._1;
      var nextW = backPath._0;
      var children = findConnection(frontPath._0, nextW, frontPath._1, back);
      if (children !== undefined) {
        return /* NewBlossom */ {
          _0: children,
        };
      }
      _backPath = traceBackward(nextW, back);
      continue;
    }
    var front = frontPath._1;
    var lastV = frontPath._0;
    if (backPath.TAG === /* DeadEnd */ 0) {
      var children$1 = findConnection(lastV, backPath._0, front, backPath._1);
      if (children$1 !== undefined) {
        return /* NewBlossom */ {
          _0: children$1,
        };
      }
      _frontPath = traceForward(lastV, front);
      continue;
    }
    var back$1 = backPath._1;
    var nextW$1 = backPath._0;
    var children$2 = findConnection(lastV, nextW$1, front, back$1);
    if (children$2 !== undefined) {
      return /* NewBlossom */ {
        _0: children$2,
      };
    }
    var backPath$1 = traceBackward(nextW$1, back$1);
    if (backPath$1.TAG === /* DeadEnd */ 0) {
      _backPath = backPath$1;
      _frontPath = traceForward(lastV, front);
      continue;
    }
    var children$3 = findConnection(lastV, backPath$1._0, front, backPath$1._1);
    if (children$3 !== undefined) {
      return /* NewBlossom */ {
        _0: children$3,
      };
    }
    _backPath = backPath$1;
    _frontPath = traceForward(lastV, front);
    continue;
  }
}

function bestEdgesReducerHelper(b, w, bestEdgeMap, edge) {
  var match = label(w);
  if (typeof match === "number") {
    if (match === /* Free */ 0) {
      return bestEdgeMap;
    }
  } else if (match.TAG !== /* S */ 0) {
    return bestEdgeMap;
  }
  if (eqB(w, b)) {
    return bestEdgeMap;
  } else {
    var _acc = /* [] */ 0;
    var _hasBeenSet = false;
    var _x = bestEdgeMap;
    while (true) {
      var x = _x;
      var hasBeenSet = _hasBeenSet;
      var acc = _acc;
      if (!x) {
        if (hasBeenSet) {
          return acc;
        } else {
          return {
            hd: {
              w: w,
              edge: edge,
            },
            tl: acc,
          };
        }
      }
      var bestEdgeMap$1 = x.tl;
      var bestEdge = x.hd;
      if (eq$1(w, bestEdge.w) && slack(edge) < slack(bestEdge.edge)) {
        _x = bestEdgeMap$1;
        _hasBeenSet = true;
        _acc = {
          hd: {
            w: w,
            edge: edge,
          },
          tl: acc,
        };
        continue;
      }
      _x = bestEdgeMap$1;
      _acc = {
        hd: bestEdge,
        tl: acc,
      };
      continue;
    }
  }
}

function bestEdgesReducer(b, _bestEdgeMap, _x) {
  while (true) {
    var x = _x;
    var bestEdgeMap = _bestEdgeMap;
    if (!x) {
      return bestEdgeMap;
    }
    var edge = x.hd.edge;
    var bestEdgeMap$1 = bestEdgesReducerHelper(
      b,
      eqB(edge.j.fields.inBlossom, b) ? edge.i.fields.inBlossom : edge.j.fields.inBlossom,
      bestEdgeMap,
      edge
    );
    _x = x.tl;
    _bestEdgeMap = bestEdgeMap$1;
    continue;
  }
}

function computeBestEdges(b) {
  return reduce$1(
    /* [] */ 0,
    function (bestEdgeMap, param) {
      var node = param.node;
      var bestEdgeMap$1;
      var exit = 0;
      var node$1;
      if (node.TAG === /* Vertex */ 0) {
        node$1 = node;
        exit = 1;
      } else {
        var blossomBestEdges = node._0.fields.blossomBestEdges;
        if (blossomBestEdges) {
          bestEdgeMap$1 = bestEdgesReducer(b, bestEdgeMap, blossomBestEdges);
        } else {
          node$1 = node;
          exit = 1;
        }
      }
      if (exit === 1) {
        bestEdgeMap$1 = reduce$2(
          bestEdgeMap,
          function (bestEdgeMap, param) {
            var neighbors = param.fields.neighbors;
            var _bestEdgeMap = bestEdgeMap;
            var _x = neighbors;
            while (true) {
              var x = _x;
              var bestEdgeMap$1 = _bestEdgeMap;
              if (!x) {
                return bestEdgeMap$1;
              }
              var endpoint = x.hd;
              var bestEdgeMap$2 = bestEdgesReducerHelper(
                b,
                toVertex(endpoint).fields.inBlossom,
                bestEdgeMap$1,
                endpoint._0
              );
              _x = x.tl;
              _bestEdgeMap = bestEdgeMap$2;
              continue;
            }
          },
          node$1
        );
      }
      if (node.TAG === /* Vertex */ 0) {
        node._0.bestEdge = undefined;
      } else {
        var b$1 = node._0;
        b$1.bestEdge = undefined;
        b$1.fields.blossomBestEdges = /* [] */ 0;
      }
      return bestEdgeMap$1;
    },
    b.fields.children
  );
}

function makeBlossom(graph, children, queue) {
  var content = graph.nextBlossom;
  graph.nextBlossom = (content + 1) | 0;
  var b = {
    content: content,
    parent: undefined,
    dualVar: 0,
    bestEdge: undefined,
    label: label(children._0.node),
    fields: {
      children: children,
      blossomBestEdges: /* [] */ 0,
    },
  };
  forEach(function (param) {
    param.node._0.parent = b;
  }, children);
  var blossom = {
    TAG: /* Blossom */ 1,
    _0: b,
  };
  var queue$1 = reduce$2(
    queue,
    function (queue, v) {
      var oldLabel = label(v.fields.inBlossom);
      v.fields.inBlossom = blossom;
      if (typeof oldLabel === "number" || oldLabel.TAG !== /* T */ 1) {
        return queue;
      } else {
        return {
          hd: v,
          tl: queue,
        };
      }
    },
    blossom
  );
  graph.blossoms = {
    hd: b,
    tl: graph.blossoms,
  };
  b.fields.blossomBestEdges = computeBestEdges(b);
  var _x = b.fields.blossomBestEdges;
  while (true) {
    var x = _x;
    if (!x) {
      return queue$1;
    }
    var edge = x.hd.edge;
    var newBestEdge = b.bestEdge;
    b.bestEdge = newBestEdge !== undefined && slack(edge) >= slack(newBestEdge) ? b.bestEdge : edge;
    _x = x.tl;
    continue;
  }
}

function splitChildren(param, entryChild) {
  var rest = param._1;
  var base = param._0;
  var _front = /* Empty */ 0;
  var _back = rest;
  while (true) {
    var back = _back;
    var front = _front;
    if (!back) {
      if (eq$1(base.node, entryChild)) {
        return {
          TAG: /* NoSplit */ 0,
          base: base,
          rest: rest,
        };
      } else {
        return Pervasives.failwith("Entry child not found.");
      }
    }
    var back$1 = back._1;
    var child = back._0;
    if (eq$1(child.node, entryChild)) {
      return {
        TAG: /* GoForward */ 1,
        base: base,
        front: reverse(front),
        entry: child,
        back: back$1,
      };
    }
    var back$2 = back$1._1;
    var child$p = back$1._0;
    if (eq$1(child$p.node, entryChild)) {
      return {
        TAG: /* GoBackward */ 2,
        base: base,
        front: reverse$1(
          /* Odd */ {
            _0: child,
            _1: front,
          }
        ),
        entry: child$p,
        back: back$2,
      };
    }
    _back = back$2;
    _front = /* Even */ {
      _0: child$p,
      _1: /* Odd */ {
        _0: child,
        _1: front,
      },
    };
    continue;
  }
}

function bubbleBlossomTree(_node, b, _x) {
  while (true) {
    var x = _x;
    var node = _node;
    if (x === undefined) {
      return Pervasives.failwith("There should be a parent.");
    }
    if (eq(x, b)) {
      return node;
    }
    _x = x.parent;
    _node = {
      TAG: /* Blossom */ 1,
      _0: x,
    };
    continue;
  }
}

function augment(b, v, mates, cmp) {
  var t = bubbleBlossomTree(
    {
      TAG: /* Vertex */ 0,
      _0: v,
    },
    b,
    v.parent
  );
  var mates$1;
  mates$1 = t.TAG === /* Vertex */ 0 ? mates : augment(t._0, v, mates, cmp);
  var match = splitChildren(b.fields.children, t);
  var match$1;
  switch (match.TAG | 0) {
    case /* NoSplit */ 0:
      match$1 = [/* Empty */ 0, /* Backward */ 0, b.fields.children];
      break;
    case /* GoForward */ 1:
      var back = match.back;
      var base = match.base;
      var moveList = concat$1(
        back,
        /* Odd */ {
          _0: base,
          _1: /* Empty */ 0,
        }
      );
      var children_0 = match.entry;
      var children_1 = concat$1(
        back,
        /* Odd */ {
          _0: base,
          _1: match.front,
        }
      );
      var children = /* Odd */ {
        _0: children_0,
        _1: children_1,
      };
      match$1 = [moveList, /* Forward */ 1, children];
      break;
    case /* GoBackward */ 2:
      var front = match.front;
      var base$1 = match.base;
      var moveList$1 = reverse(
        /* Even */ {
          _0: base$1,
          _1: front,
        }
      );
      var children_0$1 = match.entry;
      var children_1$1 = concat(
        match.back,
        /* Even */ {
          _0: base$1,
          _1: front,
        }
      );
      var children$1 = /* Odd */ {
        _0: children_0$1,
        _1: children_1$1,
      };
      match$1 = [moveList$1, /* Backward */ 0, children$1];
      break;
  }
  var direction = match$1[1];
  b.fields.children = match$1[2];
  var _mates = mates$1;
  var _x = match$1[0];
  while (true) {
    var x = _x;
    var mates$2 = _mates;
    if (!x) {
      return mates$2;
    }
    var match$2 = x._1;
    var child$p = match$2._0;
    var child = x._0;
    var p = direction ? child.endpoint : reverse$2(child$p.endpoint);
    var b$1 = child.node;
    var mates$3;
    mates$3 = b$1.TAG === /* Vertex */ 0 ? mates$2 : augment(b$1._0, toVertex(p), mates$2, cmp);
    var b$2 = child$p.node;
    var mates$4;
    mates$4 = b$2.TAG === /* Vertex */ 0 ? mates$3 : augment(b$2._0, toReverseVertex(p), mates$3, cmp);
    var mates$5 = setEdge(mates$4, p._0, cmp);
    _x = match$2._1;
    _mates = mates$5;
    continue;
  }
}

function relabelToBase(_nextEndpoint, _queue, mates, direction, cmp, _x) {
  while (true) {
    var x = _x;
    var queue = _queue;
    var nextEndpoint = _nextEndpoint;
    var match = x._1;
    if (!match) {
      return [nextEndpoint, queue];
    }
    var rest = match._1;
    var endpoint$p = match._0.endpoint;
    x._0.endpoint._0.allowable = /* Allowed */ 0;
    endpoint$p._0.allowable = /* Allowed */ 0;
    var queue$1 = assignT(toReverseVertex(nextEndpoint), nextEndpoint, mates, queue, cmp);
    var nextEndpoint$1 = direction ? endpoint$p : reverse$2(rest._0.endpoint);
    nextEndpoint$1._0.allowable = /* Allowed */ 0;
    _x = rest;
    _queue = queue$1;
    _nextEndpoint = nextEndpoint$1;
    continue;
  }
}

function expand(graph, b, stage, mates, queue) {
  var cmp = graph.cmp;
  var queue$1 = reduce$1(
    queue,
    function (queue, child) {
      var vertex = child.node;
      if (vertex.TAG === /* Vertex */ 0) {
        var v = vertex._0;
        v.fields.inBlossom = vertex;
        v.parent = undefined;
        return queue;
      }
      var b = vertex._0;
      b.parent = undefined;
      var match = b.dualVar;
      if (match === 0 && !stage) {
        return expand(graph, b, stage, mates, queue);
      }
      reduce$2(
        undefined,
        function (param, v) {
          v.fields.inBlossom = vertex;
        },
        vertex
      );
      return queue;
    },
    b.fields.children
  );
  var match = b.label;
  var queue$2;
  if (typeof match === "number" || !(match.TAG === /* T */ 1 && stage)) {
    queue$2 = queue$1;
  } else {
    var labelEndpoint = match._0;
    var entryNode = toReverseVertex(labelEndpoint).fields.inBlossom;
    var match$1 = splitChildren(b.fields.children, entryNode);
    var match$2;
    switch (match$1.TAG | 0) {
      case /* NoSplit */ 0:
        match$2 = [match$1.base.node, labelEndpoint, match$1.rest, queue$1];
        break;
      case /* GoForward */ 1:
        var base = match$1.base;
        var match$3 = relabelToBase(
          labelEndpoint,
          queue$1,
          mates,
          /* Forward */ 1,
          cmp,
          /* Odd */ {
            _0: match$1.entry,
            _1: concat$1(
              match$1.back,
              /* Odd */ {
                _0: base,
                _1: /* Empty */ 0,
              }
            ),
          }
        );
        match$2 = [base.node, match$3[0], match$1.front, match$3[1]];
        break;
      case /* GoBackward */ 2:
        var base$1 = match$1.base;
        var match$4 = relabelToBase(
          labelEndpoint,
          queue$1,
          mates,
          /* Backward */ 0,
          cmp,
          /* Odd */ {
            _0: match$1.entry,
            _1: reverse(
              /* Even */ {
                _0: base$1,
                _1: match$1.front,
              }
            ),
          }
        );
        match$2 = [base$1.node, match$4[0], match$1.back, match$4[1]];
        break;
    }
    var p = match$2[1];
    var base$2 = match$2[0];
    base$2._0.bestEdge = undefined;
    assignTSingle(base$2, p);
    var v = toReverseVertex(p);
    v.label = {
      TAG: /* T */ 1,
      _0: p,
    };
    queue$2 = reduce(
      match$2[3],
      function (queue, child) {
        var match = label(child.node);
        if (typeof match === "number") {
          if (match !== /* Free */ 0) {
            return queue;
          }
        } else if (match.TAG === /* S */ 0) {
          return queue;
        }
        var _x = reduce$2(/* [] */ 0, arg, child.node);
        while (true) {
          var x = _x;
          if (!x) {
            return queue;
          }
          var v = x.hd;
          var p = v.label;
          if (typeof p !== "number") {
            if (p.TAG === /* S */ 0) {
              return Pervasives.failwith("Must be labeled Free or T.");
            } else {
              return assignT(v, p._0, mates, queue, cmp);
            }
          }
          if (p !== /* Free */ 0) {
            return Pervasives.failwith("Must be labeled Free or T.");
          }
          _x = x.tl;
          continue;
        }
      },
      match$2[2]
    );
  }
  var _newList = /* [] */ 0;
  var _x = graph.blossoms;
  while (true) {
    var x = _x;
    var newList = _newList;
    if (x) {
      var rest = x.tl;
      var b$p = x.hd;
      if (eq(b, b$p)) {
        _x = rest;
        continue;
      }
      _x = rest;
      _newList = {
        hd: b$p,
        tl: newList,
      };
      continue;
    }
    graph.blossoms = newList;
    return queue$2;
  }
}

function getMinDualVar(param) {
  var _minDualVar = param.maxWeight;
  var _x = param.vertices;
  while (true) {
    var x = _x;
    var minDualVar = _minDualVar;
    if (!x) {
      return minDualVar;
    }
    var dualVar = x.hd.dualVar;
    _x = x.tl;
    _minDualVar = minDualVar < dualVar ? minDualVar : dualVar;
    continue;
  }
}

function threeHelper(deltaType, x) {
  var match = x.parent;
  if (match !== undefined) {
    return deltaType;
  }
  var edge = x.bestEdge;
  if (edge === undefined) {
    return deltaType;
  }
  var match$1 = x.label;
  if (typeof match$1 === "number") {
    if (match$1 === /* Free */ 0) {
      return deltaType;
    }
  } else if (match$1.TAG !== /* S */ 0) {
    return deltaType;
  }
  var kslack = slack(edge) / 2;
  if (deltaType !== undefined && kslack >= deltaType._0) {
    return deltaType;
  } else {
    return {
      TAG: /* Three */ 2,
      _0: kslack,
      _1: edge,
    };
  }
}

function one(cardinality, graph) {
  var deltaType =
    cardinality === "Max"
      ? undefined
      : {
          TAG: /* One */ 0,
          _0: getMinDualVar(graph),
        };
  var _deltaType = deltaType;
  var _x = graph.vertices;
  while (true) {
    var x = _x;
    var deltaType$1 = _deltaType;
    if (!x) {
      var _deltaType$1 = deltaType$1;
      var _x$1 = graph.vertices;
      while (true) {
        var x$1 = _x$1;
        var deltaType$2 = _deltaType$1;
        if (!x$1) {
          var _deltaType$2 = deltaType$2;
          var _x$2 = graph.blossoms;
          while (true) {
            var x$2 = _x$2;
            var deltaType$3 = _deltaType$2;
            if (!x$2) {
              var _deltaType$3 = deltaType$3;
              var _x$3 = graph.blossoms;
              while (true) {
                var x$3 = _x$3;
                var deltaType$4 = _deltaType$3;
                if (!x$3) {
                  if (deltaType$4 !== undefined) {
                    return deltaType$4;
                  }
                  var delta = getMinDualVar(graph);
                  return {
                    TAG: /* One */ 0,
                    _0: delta > 0 ? delta : 0,
                  };
                }
                var b = x$3.hd;
                var match = b.parent;
                var deltaType$5;
                if (match !== undefined) {
                  deltaType$5 = deltaType$4;
                } else {
                  var dualVar = b.dualVar;
                  var match$1 = b.label;
                  deltaType$5 =
                    typeof match$1 === "number" ||
                    !(match$1.TAG === /* T */ 1 && !(deltaType$4 !== undefined && dualVar >= deltaType$4._0))
                      ? deltaType$4
                      : {
                          TAG: /* Four */ 3,
                          _0: dualVar,
                          _1: b,
                        };
                }
                _x$3 = x$3.tl;
                _deltaType$3 = deltaType$5;
                continue;
              }
            }
            _x$2 = x$2.tl;
            _deltaType$2 = threeHelper(deltaType$3, x$2.hd);
            continue;
          }
        }
        _x$1 = x$1.tl;
        _deltaType$1 = threeHelper(deltaType$2, x$1.hd);
        continue;
      }
    }
    var v = x.hd;
    var match$2 = v.bestEdge;
    var match$3 = label(v.fields.inBlossom);
    var deltaType$6;
    if (match$2 !== undefined && match$3 === 0) {
      var kslack = slack(match$2);
      deltaType$6 =
        deltaType$1 !== undefined && kslack >= deltaType$1._0
          ? deltaType$1
          : {
              TAG: /* Two */ 1,
              _0: kslack,
              _1: match$2,
            };
    } else {
      deltaType$6 = deltaType$1;
    }
    _x = x.tl;
    _deltaType = deltaType$6;
    continue;
  }
}

function augmentMatchingLoop(_mates, _s, _p, cmp) {
  while (true) {
    var p = _p;
    var s = _s;
    var mates = _mates;
    var b = s.fields.inBlossom;
    var mates$1;
    mates$1 = b.TAG === /* Vertex */ 0 ? mates : augment(b._0, s, mates, cmp);
    var mates$2 = set(mates$1, s, p, cmp);
    var endpoint = label(s.fields.inBlossom);
    if (typeof endpoint === "number") {
      if (endpoint === /* Free */ 0) {
        return Pervasives.failwith("Required S vertex.");
      } else {
        return mates$2;
      }
    }
    if (endpoint.TAG !== /* S */ 0) {
      return Pervasives.failwith("Required S vertex.");
    }
    var tInBlossom = toVertex(endpoint._0).fields.inBlossom;
    var p$1 = label(tInBlossom);
    if (typeof p$1 === "number") {
      return Pervasives.failwith("Required T vertex.");
    }
    if (p$1.TAG !== /* T */ 1) {
      return Pervasives.failwith("Required T vertex.");
    }
    var p$2 = p$1._0;
    var s$1 = toVertex(p$2);
    var j = toReverseVertex(p$2);
    var mates$3;
    mates$3 = tInBlossom.TAG === /* Vertex */ 0 ? mates$2 : augment(tInBlossom._0, j, mates$2, cmp);
    var mates$4 = set(mates$3, j, p$2, cmp);
    _p = reverse$2(p$2);
    _s = s$1;
    _mates = mates$4;
    continue;
  }
}

function scanNeighbors(vertex, graph, mates, queue) {
  var cmp = graph.cmp;
  var match = vertex.fields;
  var neighbors = match.neighbors;
  var inBlossom = match.inBlossom;
  var _queue = queue;
  var _x = neighbors;
  while (true) {
    var x = _x;
    var queue$1 = _queue;
    if (!x) {
      return {
        TAG: /* NotAugmented */ 1,
        _0: queue$1,
        _1: mates,
      };
    }
    var neighbors$1 = x.tl;
    var endpoint = x.hd;
    var neighbor = toVertex(endpoint);
    if (eq$1(inBlossom, neighbor.fields.inBlossom)) {
      _x = neighbors$1;
      continue;
    }
    var edge = endpoint._0;
    var kslack = slack(edge);
    var match$1 = edge.allowable;
    if (match$1 && kslack <= 0) {
      edge.allowable = /* Allowed */ 0;
    }
    var match$2 = edge.allowable;
    if (match$2) {
      var match$3 = label(neighbor.fields.inBlossom);
      var exit = 0;
      exit = typeof match$3 === "number" ? (match$3 === /* Free */ 0 ? 2 : 1) : match$3.TAG === /* S */ 0 ? 1 : 2;
      switch (exit) {
        case 1:
          if (inBlossom.TAG === /* Vertex */ 0) {
            var v = inBlossom._0;
            var bestEdge = v.bestEdge;
            if (bestEdge !== undefined && kslack >= slack(bestEdge)) {
            } else {
              v.bestEdge = edge;
            }
          } else {
            var b = inBlossom._0;
            var bestEdge$1 = b.bestEdge;
            if (bestEdge$1 !== undefined && kslack >= slack(bestEdge$1)) {
            } else {
              b.bestEdge = edge;
            }
          }
          _x = neighbors$1;
          continue;
        case 2:
          var match$4 = neighbor.label;
          if (match$4 === 0) {
            var bestEdge$2 = neighbor.bestEdge;
            if (bestEdge$2 !== undefined && kslack >= slack(bestEdge$2)) {
            } else {
              neighbor.bestEdge = edge;
            }
            _x = neighbors$1;
            continue;
          }
          _x = neighbors$1;
          continue;
      }
    } else {
      var match$5 = label(neighbor.fields.inBlossom);
      if (typeof match$5 === "number") {
        if (match$5 === /* Free */ 0) {
          var queue$2 = assignT(neighbor, reverse$2(endpoint), mates, queue$1, cmp);
          _x = neighbors$1;
          _queue = queue$2;
          continue;
        }
      } else if (match$5.TAG !== /* S */ 0) {
        var match$6 = neighbor.label;
        if (match$6 === 0) {
          var p = reverse$2(endpoint);
          neighbor.label = {
            TAG: /* T */ 1,
            _0: p,
          };
          _x = neighbors$1;
          continue;
        }
        _x = neighbors$1;
        continue;
      }
      var children = scanForBlossom(edge);
      if (!children) {
        return {
          TAG: /* Augmented */ 0,
          _0: augmentMatchingLoop(
            augmentMatchingLoop(
              mates,
              edge.i,
              {
                TAG: /* J */ 1,
                _0: edge,
              },
              cmp
            ),
            edge.j,
            {
              TAG: /* I */ 0,
              _0: edge,
            },
            cmp
          ),
        };
      }
      var queue$3 = makeBlossom(graph, children._0, queue$1);
      _x = neighbors$1;
      _queue = queue$3;
      continue;
    }
  }
}

function labelingLoop(graph, _mates, _x) {
  while (true) {
    var x = _x;
    var mates = _mates;
    if (!x) {
      return {
        TAG: /* NotAugmented */ 1,
        _0: /* [] */ 0,
        _1: mates,
      };
    }
    var augmented = scanNeighbors(x.hd, graph, mates, x.tl);
    if (augmented.TAG === /* Augmented */ 0) {
      return augmented;
    }
    _x = augmented._0;
    _mates = augmented._1;
    continue;
  }
}

function substage(graph, _queue, _mates, cardinality) {
  while (true) {
    var mates = _mates;
    var queue = _queue;
    var augmented = labelingLoop(graph, mates, queue);
    if (augmented.TAG === /* Augmented */ 0) {
      return augmented;
    }
    var mates$1 = augmented._1;
    var queue$1 = augmented._0;
    var delta = one(cardinality, graph);
    switch (delta.TAG | 0) {
      case /* One */ 0:
        updateDualVarsByDelta(graph, delta._0);
        return {
          TAG: /* NotAugmented */ 1,
          _0: queue$1,
          _1: mates$1,
        };
      case /* Two */ 1:
        var edge = delta._1;
        updateDualVarsByDelta(graph, delta._0);
        var match = label(edge.i.fields.inBlossom);
        var nextVertex = match === 0 ? edge.j : edge.i;
        var queue$2 = {
          hd: nextVertex,
          tl: queue$1,
        };
        edge.allowable = /* Allowed */ 0;
        _mates = mates$1;
        _queue = queue$2;
        continue;
      case /* Three */ 2:
        var edge$1 = delta._1;
        updateDualVarsByDelta(graph, delta._0);
        var queue_0 = edge$1.i;
        var queue$3 = {
          hd: queue_0,
          tl: queue$1,
        };
        edge$1.allowable = /* Allowed */ 0;
        _mates = mates$1;
        _queue = queue$3;
        continue;
      case /* Four */ 3:
        updateDualVarsByDelta(graph, delta._0);
        var queue$4 = expand(graph, delta._1, /* NotEndstage */ 1, mates$1, queue$1);
        _mates = mates$1;
        _queue = queue$4;
        continue;
    }
  }
}

function resetStage(graph, mates) {
  var vertices = graph.vertices;
  var blossoms = graph.blossoms;
  var cmp = graph.cmp;
  var _x = graph.edges;
  while (true) {
    var x = _x;
    if (!x) {
      var _x$1 = blossoms;
      while (true) {
        var x$1 = _x$1;
        if (!x$1) {
          var _queue = /* [] */ 0;
          var _x$2 = vertices;
          while (true) {
            var x$2 = _x$2;
            var queue = _queue;
            if (!x$2) {
              return queue;
            }
            var rest = x$2.tl;
            var v = x$2.hd;
            if (has(mates, v, cmp)) {
              v.bestEdge = undefined;
              v.label = /* Free */ 0;
              _x$2 = rest;
              continue;
            }
            v.bestEdge = undefined;
            var queue$1 = assignS(v, /* SingleS */ 1, queue);
            _x$2 = rest;
            _queue = queue$1;
            continue;
          }
        }
        var b = x$1.hd;
        b.bestEdge = undefined;
        b.fields.blossomBestEdges = /* [] */ 0;
        b.label = /* Free */ 0;
        _x$1 = x$1.tl;
        continue;
      }
    }
    x.hd.allowable = /* NotAllowed */ 1;
    _x = x.tl;
    continue;
  }
}

function expandAllSBlossoms(graph, mates, queue) {
  var _x = graph.blossoms;
  while (true) {
    var x = _x;
    if (!x) {
      return;
    }
    var b = x.hd;
    var match = b.parent;
    if (match === undefined) {
      var match$1 = b.dualVar;
      if (match$1 === 0) {
        var match$2 = b.label;
        var exit = 0;
        if (typeof match$2 === "number") {
          if (match$2 !== /* Free */ 0) {
            exit = 1;
          }
        } else if (match$2.TAG === /* S */ 0) {
          exit = 1;
        }
        if (exit === 1) {
          expand(graph, b, /* Endstage */ 0, mates, queue);
        }
      }
    }
    _x = x.tl;
    continue;
  }
}

function comparableToBelt(id) {
  return id.BeltCmp;
}

function make(cardinalityOpt, edges, id) {
  var cardinality = cardinalityOpt !== undefined ? cardinalityOpt : "NotMax";
  var graph = makeGraph(edges, id);
  var _mates;
  var _stageNum = 0;
  while (true) {
    var stageNum = _stageNum;
    var mates = _mates;
    if (stageNum === graph.vertexSize) {
      return Belt_Map.packIdData(id.BeltCmp, undefined);
    }
    var queue = resetStage(graph, mates);
    var mates$1 = substage(graph, queue, mates, cardinality);
    if (mates$1.TAG !== /* Augmented */ 0) {
      return Belt_Map.packIdData(id.BeltCmp, mates$1._1);
    }
    var mates$2 = mates$1._0;
    expandAllSBlossoms(graph, mates$2, queue);
    _stageNum = (stageNum + 1) | 0;
    _mates = mates$2;
    continue;
  }
}

function get(mates, v) {
  var p = Belt_Map.get(mates, v);
  if (p !== undefined) {
    return Caml_option.some(toVertex(p).content);
  }
}

function reduceU(mates, init, f) {
  return Belt_Map.reduceU(mates, init, function (acc, v1, p) {
    return f(acc, v1, toVertex(p).content);
  });
}

function reduce$3(mates, init, f) {
  return reduceU(mates, init, Curry.__3(f));
}

function forEachU(mates, f) {
  return Belt_Map.forEachU(mates, function (v1, p) {
    return f(v1, toVertex(p).content);
  });
}

function forEach$1(mates, f) {
  return forEachU(mates, Curry.__2(f));
}

function toList(mates) {
  return Belt_Map.reduceU(mates, /* [] */ 0, function (acc, v, p) {
    return {
      hd: [v, toVertex(p).content],
      tl: acc,
    };
  });
}

function toMap(mates) {
  return Belt_Map.mapU(mates, function (mate) {
    return toVertex(mate).content;
  });
}

function unsafeComparableFromBeltU(id, cmp) {
  var cmp$1 = makeCmp(cmp);
  var K = Belt_Id.MakeComparableU({
    cmp: cmp$1,
  });
  return {
    cmp: cmp,
    edgeCmp: K.cmp,
    BeltCmp: id,
  };
}

function unsafeComparableFromBelt(id, cmp) {
  var cmp$1 = Curry.__2(cmp);
  var cmp$2 = makeCmp(cmp$1);
  var K = Belt_Id.MakeComparableU({
    cmp: cmp$2,
  });
  return {
    cmp: cmp$1,
    edgeCmp: K.cmp,
    BeltCmp: id,
  };
}

function comparable(cmp) {
  var M = {
    cmp: cmp,
  };
  var cmp$1 = Curry.__2(cmp);
  var Cmp = Belt_Id.MakeComparable(M);
  var cmp$2 = makeCmp(cmp$1);
  var K = Belt_Id.MakeComparableU({
    cmp: cmp$2,
  });
  return {
    cmp: cmp$1,
    edgeCmp: K.cmp,
    BeltCmp: Cmp,
  };
}

function comparableU(cmp) {
  var M = {
    cmp: cmp,
  };
  var Cmp = Belt_Id.MakeComparableU(M);
  var cmp$1 = makeCmp(cmp);
  var K = Belt_Id.MakeComparableU({
    cmp: cmp$1,
  });
  return {
    cmp: cmp,
    edgeCmp: K.cmp,
    BeltCmp: Cmp,
  };
}

var Cmp = comparableU(Caml.caml_int_compare);

function make$1(param, param$1) {
  return make(param, param$1, Cmp);
}

var Int = {
  Cmp: Cmp,
  make: make$1,
};

var Cmp$1 = comparableU(Caml.caml_string_compare);

function make$2(param, param$1) {
  return make(param, param$1, Cmp$1);
}

var $$String = {
  Cmp: Cmp$1,
  make: make$2,
};

var isEmpty = Belt_Map.isEmpty;

var has$1 = Belt_Map.has;

function MakeComparable(funarg) {
  var cmp = funarg.cmp;
  var cmp$1 = Curry.__2(cmp);
  var Cmp = Belt_Id.MakeComparable(funarg);
  var cmp$2 = makeCmp(cmp$1);
  var K = Belt_Id.MakeComparableU({
    cmp: cmp$2,
  });
  return {
    cmp: cmp$1,
    edgeCmp: K.cmp,
    BeltCmp: Cmp,
  };
}

function MakeComparableU(funarg) {
  var cmp = funarg.cmp;
  var Cmp = Belt_Id.MakeComparableU(funarg);
  var cmp$1 = makeCmp(cmp);
  var K = Belt_Id.MakeComparableU({
    cmp: cmp$1,
  });
  return {
    cmp: cmp,
    edgeCmp: K.cmp,
    BeltCmp: Cmp,
  };
}

export {
  Internal,
  make,
  get,
  reduce$3 as reduce,
  reduceU,
  forEach$1 as forEach,
  forEachU,
  toMap,
  toList,
  isEmpty,
  has$1 as has,
  Int,
  $$String,
  unsafeComparableFromBelt,
  unsafeComparableFromBeltU,
  MakeComparable,
  MakeComparableU,
  comparable,
  comparableU,
  comparableToBelt,
};
/* Cmp Not a pure module */
